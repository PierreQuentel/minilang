<!doctype html>
<html>
<head>
<meta charset="utf-8">
<script type="text/javascript" src="builtins.js"></script>
<script type="text/javascript" src="ml2js.js"></script>
<link rel="stylesheet" href="minilang.css">
</head>

<body>
<button id="run">run</button>
<br>
<table width="100%">
<tr>
<td valign="top">
<textarea id="editor" rows="30" cols="60" autocomplete="off">
# Fibonacci suite
fibo(n) =
  n == 0 ?
    ! 1
  n == 1 ?
    ! 1
  ! fibo(n - 2) + fibo(n - 1)

("fibo(10)", fibo(10)) >>

# Factorial
fact(n) =
  res = 1
  i = 2
  @
    i > n ?
      ! res
    res = res * i
    i = i + 1

("fact(10)", fact(10)) >>

# Palindrome
is_palindrome(s) =
  len = 0
  @ s
    len = len + 1
  i0 = 0
  i1 = len - 1
  res = 1
  @
    s[i0] != s[i1] ?
      res = 0
      !
    i0 = i0 + 1
    i1 = i1 - 1
    i1 <= i0 ?
      !

  res == 1 ?
    ! s + " is a palindrome"
  res == 0 ?
    ! s + " is not a palindrome"

is_palindrome("laval") >>
is_palindrome("abba") >>
is_palindrome("azerty") >>

# stack
empty(t) =
  t ?
    ! "false"
  ! "true"

push(t, item) =
  t <= item

pop(t) =
  res = t[-1]
  t[-1:] = []
  ! res

t = []
@ 5:i
  push(t, i * 2)

("after push", t) >>
("pop pop pop", pop(t), pop(t), pop(t)) >>
("empty ?", empty(t)) >>

# binary search
binary_search(t, value) =
  low = 0
  len = 0
  @ t
    len = len + 1
  high = len - 1
  @
    low > high ?
      ! -1
    mid = (low + high) // 2
    value == t[mid] ?
      ! mid
    t[mid] > value ?
      high = mid - 1
    t[mid] < value ?
      low = mid + 1

t = [0, 1, 2, 5, 7, 10]
("position of", 2, "in", t, binary_search(t, 2)) >>
("position of", 3, "in", t, binary_search(t, 3)) >>

# power and root
pow(x, n) =
  # real x to power n
  res = 1
  @ [:n]
    res = res * x
  ! res

("2 ** 3 =", pow(2, 3)) >>

root(x, n) =
  # n-root of real positive number x
  # Newton formula : u = (((n - 1) * u) + (x / u ** (n - 1))) / n
  u = x / n
  precision = 0.00000000000001
  @
    u1 = (n - 1) * u
    u2 = x / pow(u, n - 1)
    u = (u1 + u2) / n
    delta = x - pow(u, n)
    delta < 0 ?
      delta = -delta
    delta < precision ?
      ! u

("square root of 2", root(2, 2)) >>
("root(2, 3)", root(2, 3)) >>

# closest pair
closest_pair(t) =
  # brute force algorithm
  i0 = 0
  i1 = 1
  dmin = -1
  closest = [-1, -1]
  @
    dx = points[i0].x - points[i1].x
    dy = points[i0].y - points[i1].y
    d = (dx * dx) + (dy * dy)
    dmin != -1 ?
      d < dmin ?
        dmin = d
        closest[0] = i0
        closest[1] = i1
    dmin == -1 ?
      dmin = d
      closest[0] = i0
      closest[1] = i1
    i1 = i1 + 1
    i1 == nb_points ?
      i0 = i0 + 1
      i1 = i0 + 1
      i0 == nb_points - 1 ?
        !
  ! [closest, dmin]

point = [x=0, y=0]
points = [[95, 67], [44, 84], [10, 36], [61, 7],
          [64, 52], [7, 71], [33, 38], [54, 82],
          [68, 91], [23, 63], [61, 37], [57, 80],
          [12, 90], [84, 18], [60, 32], [60, 52],
          [42, 22], [52, 20], [36, 92], [74, 0]]

nb_points = 0
@ points: pt
  points[nb_points] = point(pt[0], pt[1])
  nb_points = nb_points + 1

result = closest_pair(points)
closest = result[0]
dmin = result[1]

("closest pair", points[closest[0]], points[closest[1]],
      "distance", dmin, root(dmin, 2)) >>

# 99 bottles of beer
s1 = "bottles of beer"
s2 = "on the wall"
s3 = "Take one down, pass it around"

count = 99
@
    count == 0 ?
      !
    (count, s1, s2) >>
    (count, s1) >>
    s3 >>
    count = count - 1
    count == 1 ?
        s1 = "bottle of beer"
    (count, s1, s2) >>
    () >>

</textarea>
</td>
<td valign="top">

<textarea id="output" cols=60 rows=30 autocomplete="off"></textarea>

</body>
</html>